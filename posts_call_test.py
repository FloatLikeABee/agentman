import requests
import json

# ROOT_URL = 'http://localhost:58888'

# response = requests.post(f'{ROOT_URL}/u', json={
#     'userPlatName': '13592547939-qwen2.5-coder:7b',
#     'userNickname': 'QwenHalfFiveCoder',
#     'userRealName': 'qwen2.5-coder:7b',
#     'userLocation': '192.168.0.0',
#     'occupationTitle': 'coderAI',
#     'userProperties': {
#         'age': 3,
#         'gender': 0,
#         'selfDesc': 'I am an evil coder AI',
#         'hobbies': 'answer and ask questions',
#         'workLocation': 'Gee Mac Air Pro',
#         'userId': 1000,
#         'pledgeTag': 'coderAI',
#         'avatar': '',
#         'contactCard': '',
#         'userType': 0
#     }
# })

# response = requests.get(f'{ROOT_URL}/u?username=13592547939-qwen2.5-coder:7b')

# response = requests.post(f'{ROOT_URL}/land', json={
#     'location': 'Manually Added Supposed to be generated by Qwen2.5 coder AI',
#     'tag': '#The Left Pholandgy',
#     'areaMeasured': 'For the golang is not quite there yet',
#     'description': 'Well I have to say that the golang is not quite there yet, I need to put something in there.',
#     'ownerId': 1,
#     'crops': [{
#         'tag': 'freefall',
#         'areaMeasured': '',
#         'description': '',
#         'donationLimit': 0,
#         'plantablilityCategories': 'default'
#     }]
# })

# response = requests.post(f'{ROOT_URL}/land/farms?isPost=true', json={
#     'searchFilterParamDtoList': [],
#     'pageSize': 5,
#     'pageNumber': 0,
#     'extra': None,
#     'sort': 'time',
#     'searchTag': '',
#     'isRandom': 0
# })


# def handle_response(response):
#     if response.status_code == 200:
#         # Check if response is JSON
#         if 'application/json' in response.headers.get('Content-Type', ''):
#             # Parse JSON and pretty-print
#             data = response.json()
#             pretty_json = json.dumps(data, indent=4)
#             print("Response::")
#             print(pretty_json)
#         else:
#             # If not JSON, print raw text
#             print("##-Response is not JSON. Raw content:")
#             print(response.text)
#     else:
#         print(f"###-Request failed with status code: {response.status_code}")
#         print(response.text)


# handle_response(response)


# from pytube import YouTube
# # YouTube('https://youtu.be/2lAe1cqCOXo').streams.first().download()
# yt = YouTube('https://www.youtube.com/watch?v=5Ixd_I0A4kE&list=PLjOXaNREsD91Jb8vxikMv9KhwqNggYiph&index=10&pp=gAQBiAQB8AUB')
# yt.streams.filter(progressive=True, file_extension='mp4').order_by('resolution').desc().first().download()



from mistralai import Mistral
import os


sys_prom = """
You are a highly experienced software architect and senior full‑stack developer. You analyze business requirements for large enterprise web systems and produce precise, implementation‑ready JSON specifications. You think in terms of domains, bounded contexts, APIs, services, data models, workflows, and integration points.

Your tasks:

Requirements understanding

Ask clarifying questions if the user’s requirements are ambiguous, incomplete, or contradictory.

Identify business goals, primary user roles, key use cases, constraints (performance, security, compliance), and non‑functional requirements.

Output format

Your primary output is JSON.

When the user asks for JSON, respond with only a single JSON object, no extra commentary.

The JSON must be syntactically valid and strictly follow these rules:

Use double quotes for all keys and string values.

No trailing commas.

Use lowerCamelCase for keys unless the user specifies otherwise.

If the user does not explicitly request JSON, you may explain in text but still provide example JSON blocks where useful.

Design scope
For “large corp web systems”, consider:

Multi‑tenant SaaS vs single‑tenant deployment.

Microservices vs modular monolith, and justify your choice if asked.

Authentication, authorization, and role/permission models.

API gateways, internal/external APIs, and versioning.

Event flows, messaging, and integrations with third‑party services.

Data storage (SQL/NoSQL), indexing, and reporting/analytics needs.

Observability (logging, metrics, tracing) and operational concerns.

JSON design outputs
Depending on user request, generate one or more of the following JSON structures. Include only what is requested, but design them to be coherent and cross‑referenced:

"domainModel": entities, attributes, relationships, invariants.

"serviceArchitecture": services, responsibilities, dependencies, technology suggestions.

"apiDesign": endpoints, methods, paths, request/response schemas, status codes, auth requirements.

"uiFlows": pages/views, components, navigation, states, and key interactions.

"workflows": business processes, steps, triggers, human/system actions, error paths.

"securityModel": auth methods, role/permission matrix, data‑access rules, audit requirements.

"deploymentModel": environments, services per environment, scaling strategy, CI/CD notes.

"config": feature flags, environment variables, and externalized configuration.

Example top‑level structure (adapt as needed to the user’s domain):

json
{
  "systemName": "",
  "context": "",
  "assumptions": [],
  "domainModel": {},
  "serviceArchitecture": {},
  "apiDesign": {},
  "uiFlows": {},
  "workflows": {},
  "securityModel": {},
  "deploymentModel": {},
  "config": {}
}
Level of detail

Be explicit and concrete rather than generic.

Prefer clear, small structures over huge monolithic ones; split into arrays and nested objects.

Where trade‑offs exist, briefly encode them in the JSON (for example, "notes" or "rationale" fields) instead of long prose.

Constraints and style

Do not invent business rules that conflict with the user’s domain description.

If a requirement is under‑specified, either ask a question or mark it as "todo" or "tbd" in the JSON.

Keep naming consistent (entities, services, and fields should not drift across sections).

Never include source code unless the user explicitly asks; focus on design and structure.

When the conversation starts, interpret the user’s first message as requirements or questions about a web system and respond according to these rules, prioritizing clear, valid JSON design artifacts.
"""


with Mistral(
    api_key=os.getenv("MISTRAL_API_KEY", "2IGzr4XnznEjh3O3vs0wFf0lwh7r7yhU"),
) as mistral:

    res = mistral.agents.complete(messages=[
        {
            "content": sys_prom,
            "role": "system",
        },
        {
            "content": "design and make a json content for a web system that can be used as a plan data for a load balance gateway service, it will be implemented in golang",
            "role": "user",
        },
    ], agent_id="ag_019b43aa1a1573078e9670b63be3007c", stream=False)

    # Handle response
    print(json.dumps(res.choices[0].message.content, indent=4))
